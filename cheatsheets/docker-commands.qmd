---
title: "Docker Commands Cheatsheet"
author: "Junaid Butt"
date: 2025-09-17
categories: [docker, containers, devops]
description: "Comprehensive Docker commands reference guide with setup, basic commands, Dockerfile, and Docker Compose."

---

## Setup

- Docker install via this link: `https://hub.docker.com/editions/community/docker-ce-desktop-mac/`
- Docker commands are run in the terminal

## Basic Docker Commands

1. List Docker images

```bash
docker images
```

2. List all running Docker containers
```bash
docker ps
```

3. Inspect a Docker container
```bash
docker inspect <container id/name>
```

4. Print Docker container logs
```bash
docker logs <container id/name>
```

5. Run a docker image that doesn't persist
```bash
docker run --rm -p <port_on_container>:<port_on_local_machine> <image name>
```

6. Mount a volume from a container to a local directory
```bash
docker run -v <local directory>:<container directory> <image name>
docker run --mount type=bind,source=/data/mysql,target=/var/lib/mysql <image name>
```

7. Run a docker image with a place to save work in the container to the local machine
```bash
docker run --rm -p <port_on_container>:<port_on_local_machine> -v <local_directory_to_save_work_to>:/home/rstudio/<container_directory_name_to_save_work_to> <image name>
```

8. Save Docker image
```bash
docker commit -m <commit message> <container id> <new image save name>
```

9. Pull a docker image but don't run it
```bash
docker pull <image name>
```

10. Remove docker image
```bash
docker image rm <image name>
docker image rm <image ID>
```

11. Remove dangling docker images: listed as `<none>:<none>`
```bash
docker rmi $(docker images -f "dangling=true" -q)
docker rmi $(docker images -f "dangling=true" -q) -f  # Force delete dangling images
```

12. Save Docker image to tar file
```bash
docker save <image name> > <image name>.tar
```

13. Load Docker container from archived tar file
```bash
docker load --input <image name>.tar
```

14. Build Docker image specified in a Docker file
```bash
docker build -t <name of image> .
```

15. Build Docker image with a custom Dockerfile name
```bash
docker build -t <name of image>:<latest> -f <Dockerfile name> .
```

16. Stop a running Docker container
```bash
docker stop <image ID>
```

17. Access the Bash Shell in a running docker container
```bash
# 1. Run docker container
docker run --rm -p <port_on_container>:<port_on_local_machine> <image name>

# 2. Obtain the name of existing container(s)
docker ps

# 3. Exec into a running docker container to access it's Bash Shell
docker exec -it <container_name> /bin/bash

# 4. Come out of a docker container that has been exec'd into
# Press: Ctrl+D
```

18. Run a docker container but does not attach container to terminal
```bash
docker run -d <image name>
```

19. Attach a running docker container to the current terminal
```bash
docker attach <image name>
```

20. Docker Debugging - Run & Exec in one step
```bash
docker run -it --entrypoint /bin/bash --rm --name <name_given_to_container> <image_name>:<tag>

# Example:
docker run -it --entrypoint /bin/bash --rm --name runner geodn-runner:latest
```

21. Providing build args to Docker via CLI
```bash
docker build --build-arg <ARG_NAME_IN_DOCKERFILE>=<token> -t <image_name>:<tag> .

# Example:
docker build --build-arg GITHUB_TOKEN=<token> -t geodn-runner:latest .
```

22. MultiPlatform Image support in Dockerfile
```dockerfile
FROM --platform=linux/amd64 python:3.8
```

23. Prune Docker images
```bash
docker system prune --force
```

24. Pulling and Pushing to remote registry
```bash
# Login to Remote Registry
docker login {registry_url}

# Optional Build Image
docker build -t {registry}/{imagename}:{tag} .

# Tag local image with remote registry
docker tag {local_imagename}:{tag} {registry}/{imagename}:{tag}

# Push to remote registry
docker push {registry}/{imagename}:{tag}
```

## Dockerfile

- Dockerfiles are a set of instructions on how to add things to a base image. They build custom images up in a series of *layers*. In a new text file called `Dockerfile`.
- Sample Dockerfile:

```dockerfile
FROM rocker/verse:4.0.2  # Insert R version to load

RUN R -e "install.packages(c('pkg_1',..., 'pkg_n'), repos = 'http://cran.us.r_project.org')"

ADD my_analysis.R /home/rstudio
```

- Build image specified in Dockerfile:
```bash
docker build -t <name of image> .
```

**Note:** `docker build -t <name of image> .` is run (via command line) in the **same directory** as the Dockerfile and any files we want to include with an ADD command.

## Environment Variables

For Python web applications, we can set environment variables whose values are specified in a docker run command:

```python
# app.py
import os
from flask import Flask

app = Flask(__name__)

# Get environment variable
colour = os.environ.get("APP_COLOUR")

@app.route("/")
def main():
    print(colour)
    return render_template("hello.html", color=colour)

if __name__ == "__main__":
    app.run(host="0.0.0.0", port="8080")
```

To initialize the environment variable, supply it a value from the docker run command:
```bash
docker run -e APP_COLOUR=blue <image name>
```

## Sharing Docker Images

1. Create a local directory with relevant analysis and data. Call this script `my_analysis.R`.
2. In the same directory, create a Dockerfile to define a Docker image:

```dockerfile
FROM rocker/verse:4.0.2  # Insert R version to load

RUN R -e "install.packages(c('pkg_1',..., 'pkg_n'), repos = 'http://cran.us.r_project.org')"

ADD my_analysis.R /home/rstudio
```

3. Build the Docker image:
```bash
docker build -t <image name> .
```

4. On dockerhub (create an account if you don't have one), create a repository

5. Log into dockerhub from terminal:
```bash
docker login --username=username  # type in the dockerhub password when prompted
```

6. Tag docker image (to find image id number type `docker images`):
```bash
docker tag <container image id> <dockerusername>/<reponame>:<tagmessage>
```

7. Push image to the created repository:
```bash
docker push <dockerhubusername>/<reponame>
```

8. Pull docker image from dockerhub:
```bash
docker pull <dockerhubusername>/<reponame>:<tagmessage>
```

## Docker Compose

Docker Compose enables the running of Docker commands required for the execution of Docker containers to be mapped to a YAML file. This is helpful when we need to run multiple containers altogether.

### Example: MongoDB Setup

Instead of running these separate Docker Run commands:

```bash
# Docker Run for MongoDB - Runs in the terminal
docker run -d \
--name mongodb \
-p 27017:27017 \
-e MONGO_INITDB_ROOT_USERNAME=admin \
-e MONGO_INITDB_ROOT_PASSWORD=password \
--net mongo-network \
mongo

# Docker Run for Mongo Express - Runs in the terminal
docker run -d \
--name mongo-express \
-p 8080:8080 \
-e ME_CONFIG_MONGODB_ADMINUSERNAME=admin \
-e ME_CONFIG_MONGODB_ADMINPASSWORD=password \
-e ME_CONFIG_MONGODB_SERVER=mongodb \
--net mongo-network \
mongo-express
```

You can use a Docker Compose file (`mongo.yaml`):

```yaml
version: '3'
services:
  mongodb:
    image: mongo
    ports:
      - 27017:27017
    environment:
      - MONGO_INITDB_ROOT_USERNAME=admin
      - MONGO_INITDB_ROOT_PASSWORD=password
  mongo-express:
    image: mongo-express
    ports:
      - 8080:8080
    environment:
      - ME_CONFIG_MONGODB_ADMINUSERNAME=admin
      - ME_CONFIG_MONGODB_ADMINPASSWORD=password
      - ME_CONFIG_MONGODB_SERVER=mongodb
```

### Building with Docker Compose

For containers with custom Dockerfiles:

```yaml
version: '3.7'
services:
  flask:
    build: ./flask  # Directory where Dockerfile is
    container_name: flask
    restart: always
    volumes:
      - ./flask/app:/usr/src/app
    environment:
      - APP_NAME=MyFlaskApp
      - DB_USERNAME=example
    expose:
      - 8080
  nginx:
    build: ./nginx
    container_name: nginx
    restart: always
    ports:
      - "80:80"
```

### Docker Compose Commands

```bash
# Build any Docker containers in the YAML file
docker-compose -f {docker_compose_filename} build

# Start Docker containers in the YAML file
docker-compose -f {docker_compose_filename} up

# Stop Docker containers in the YAML file
docker-compose -f {docker_compose_filename} down
```

---